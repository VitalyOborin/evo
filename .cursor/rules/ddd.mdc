---
description: Проектирование домена
alwaysApply: false
---
## Правила для поддержания DDD-ориентированного подхода

### 1. Обязательные правила

1. **Использование доменных сущностей (Entities) и Value Objects (VO).**

   * Каждая сущность должна иметь уникальный идентификатор (идентичность).
   * Value Object — без идентичности, неизменяемый после создания, сравнение по структуре (по полям), а не по ссылке.
   * VO инкапсулируют примитивы и гарантируют инварианты (например, Money, Email, Address).
   * value objects предпочитаются, когда идентичность не нужна

2. **Инварианты агрегата (Consistency Boundaries).**

   * Изменения внутри агрегата должны поддерживать все инварианты сразу, до выхода из метода.
   * Внешний код не должен нарушать эти инварианты напрямую.
   * Только корневой агрегат (Aggregate Root) может быть точкой входа на изменение (через публичные методы).

3. **Инкапсуляция внутреннего состояния агрегата.**

   * Поля сущностей и VO внутри агрегата — приватные.
   * Внешние операции — через методы агрегата, не через сеттеры (public setters) или прямое изменение коллекций.
   * Коллекции внутри агрегатов должны быть обёрнуты в неизменяемые/только для чтения интерфейсы (или методы добавления/удаления, но не открывать прямую мутацию).
   * Использовать фабрики или статические конструкторы для корректной инициализации агрегатов.

4. **Язык Ubiquitous Language + именование в доменном слое.**

   * Термины домена, используемые бизнес-экспертами, должны попадать в код (имена классов, методов, сообщений).
   * Не переводить доменные термины в технические аналоги (например, “accountDebit” → “accountMinus”).
   * В каждом bounded context язык должен быть внутренне согласован.

5. **Разделение слоёв: доменный слой не зависит от инфраструктура/ORM/базы данных.**

   * В доменном слое не должно быть импорта слоёв persistence, web, IO.
   * Для доступа к внешним системам (БД, сообщения, REST, очередь) использовать интерфейсы / порты (абстракции), которые реализуются инфраструктурными адаптерами.
   * Инфраструктурные детали (ORM, SQL, HTTP, очереди) не должны “протекать” в домен.

6. **Контекстные границы (Bounded Contexts).**

   * Чётко разделять поддомены, каждый со своей моделью.
   * Не смешивать разные модели в одном контексте.
   * Между контекстами возможна интеграция через анти-коррупционные слои (Anti-Corruption Layer), перевод (translation), контрактные API, события.
   * Не создавать “единый глобальный домен” как один большой агрегат без границ.
   * (Микросервисы часто можно ставить в соответствие bounded contexts) ([learn.microsoft.com][2])

7. **События домена (Domain Events).**

   * Значимые изменения состояния агрегатов (которые важны в домене) должны порождать события.
   * События — часть доменного слоя / доменного контекста (но публикация / доставка — инфраструктурная задача).
   * Не дублировать логику “очень важного состояния” вне события, чтобы состояние и событие были согласованы.

8. **Тестируемость домена.**

   * Доменные объекты и операции должны быть юнит-тестируемыми без подгрузки инфраструктуры.
   * Тесты должны проверять бизнес-логику, а не детали ORM или базы.

---

### 2. Рекомендуемые / желательные правила

1. **Предпочитать Value Objects там, где нет смысла в идентичности.**

   * Если объект можно заменить другим с такими же полями — это VO.
   * VO проще, безопаснее, меньше “сстояний”.

2. **Паттерн Specification / Predicate / Rule объекты.**

   * Если бизнес-условие становится сложным, выносить его в спецификацию (Specification), правило или стратегию.
   * Спецификация можно комбинировать (и / или / not) для гибкости.

3. **Фабрики (Factories) и фабрики-методы для создания агрегатов и сложных объектов.**

   * Особенно когда допустимые комбинации параметров ограничены.
   * Гарантировать, что создаваемый объект сразу в корректном состоянии (инварианты, валидность).

4. **Сервисы домена (Domain Services).**

   * Логика, не принадлежащая ни одной сущности / VO, но относящаяся к домену, выносится в доменные сервисы.
   * Интерфейсы и сигнатуры сервисов используют доменные объекты.
   * Сервисы не должны знать инфраструктуру.

5. **Анти-коррупционные слои, трансляторы и адаптеры между контекстами.**

   * При интеграции между bounded contexts не использовать модели одного контекста напрямую в другом.
   * Перевод (mapping) через адаптеры / трансляторы обязателен.

6. **Версионирование событий и моделей.**

   * Если система жива долго, события и модели могут эволюционировать: предусмотреть backward compatibility, миграции событий.

7. **CQRS как вариант разделения команд и запросов.**

   * В сложных или нагруженных подсистемах полезно разделить пути (команды → агрегаты → события / состояние, запросы → проекции).
   * Но не превращать в догму — применять когда обосновано.

8. **Оптимистическая конкуренция / контроль версий агрегата.**

   * В многопоточных или распределённых системах агрегаты должны поддерживать версионность (versioning) и контроль конкуренции.

9. **Стратегии загрузки (lazy / eager) с осторожностью.**

   * В доменном слое загружать только то, что нужно для исполнения логики.
   * Не вытягивать всю ветку зависимостей “на всякий случай”.

10. **Документирование модели и эволюции через Event Storming / Domain Modeling Workshops.**

    * Периодически пересматривать границы, термины, модель с бизнес-экспертами.
    * Убирать устаревшие элементы, уточнять язык.

---

### 3. Нежелательные / запрещённые практики

1. **Запрещено: “анемичная модель” (Anemic Domain Model).**

   * Не разрешать, чтобы сущности были просто “DTO + геттеры/сеттеры”, а вся бизнес-логика была вынесена в сервисы.
   * Исключение: простые объекты, где логика минимальна — но не как правило.

2. **Нельзя смешивать инфраструктурные детали в доменной логике.**

   * Не делать прямых зависимостей на ORM (например, методы save() внутри сущности).
   * Не импортировать SQL, запросы, HTTP, очередь в домен.

3. **Не открывать внутренние коллекции / поля для внешнего изменения.**

   * Нельзя делать `public List<Item> items;` — это позволит внешнему коду нарушить инварианты.
   * Нельзя возвращать напрямую модифицируемые коллекции.

4. **Не использовать “технические” имена в домене.**

   * Например, “DbOrderRecord”, “HttpOrderDto” — такие абстракции должны быть в слоях инфраструктуры или приложении, не в домене.

5. **Не использовать глобальные состояниевые объекты (singleton-контейнеры) внутри домена.**

   * Доменные объекты должны быть самодостаточны, без скрытых глобальных зависимостей.

6. **Не выполнять запросы / операции I/O внутри доменных методов.**

   * Доменный метод не должен начинать транзакцию, делать HTTP-вызов или базовый запрос.
   * Такие задачи — на уровень инфраструктуры / application / обработчиков команд.

7. **Избегать bidirectional связи между агрегатами через сущности (двунаправленные связи).**

   * Лучше опираться на идентификаторы / слабые ссылки.
   * Слишком плотные связи нарушают границы и приводят к чрезмерной связанности.

8. **Не использовать Value Object с внутренней изменяемостью.**

   * Value Object обязательно является неизменяемым (immutable).
   * Если поля VO можно изменить, это будет нарушать семантику VO.
