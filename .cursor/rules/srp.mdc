---
description: Single Responsibility Principle (SRP)
globs:
alwaysApply: true
---
When developing an application, it is MANDATORY to follow the Single Responsibility Principle (SRP).

---

# Single Responsibility Principle (SRP) in Python

SRP: **A class, function, or module should have only one reason to change.**

That is, each component is responsible for only **one task**.

---

## ğŸ“Œ 1. Classes

âŒ Bad example:

```python
class UserManager:
def __init__(self):
self.users = {}

def add_user(self, user_id, data):
self.users[user_id] = data

def save_to_file(self, filename):
with open(filename, "w") as f:
f.write(str(self.users)) # âŒ Storage logic inside the manager
```

âœ… Good example (separate storage and management):

```python
class UserRepository:
def __init__(self):
self.users = {}

def add(self, user_id, data):
self.users[user_id] = data

def get(self, user_id):
return self.users.get(user_id)

class FileStorage:
def save(self, data, filename):
with open(filename, "w") as f:
f.write(str(data))
```

---

## ğŸ“Œ 2. Functions

âŒ Bad example:

```python
def process_order(order):
# validation
if not order.get("id"):
raise ValueError("Invalid order")
# calculation
total = sum(item["price"] for item in order["items"])
# sending notification
print(f"Order {order['id']} processed with total {total}")
```

âœ… Good example (each function does one thing):

```python
def validate_order(order):
if not order.get("id"):
raise ValueError("Invalid order")

def calculate_total(order):
return sum(item["price"] for item in order["items"])

def notify(order_id, total):
print(f"Order {order_id} processed with total {total}")

def process_order(order):
validate_order(order)
total = calculate_total(order)
notify(order["id"], total)
```

---

## ğŸ“Œ 3. Modules

âŒ Bad example:
`orders.py` contains everything: models, business logic, API.

âœ… Good example:

```
orders/
â”œâ”€â”€ models.py # DTO / dataclass
â”œâ”€â”€ services.py # business logic
â”œâ”€â”€ repository.py # working with DB
â”œâ”€â”€ api.py # REST handlers
```

---

## ğŸ“Œ 4. Exceptions

âŒ Bad example:

```python
class OrderService:
def process(self, order):
try:
# business logic
...
except Exception as e:
print("Error", e) # âŒ logging inside the service
```

âœ… Good example:

```python
class OrderService:
def process(self, order):
# business logic
...

class Logger:
def log(self, message):
print(message)
```

---

## ğŸ“Œ 5. Configuration and dependencies

âŒ Bad example:

```python
class Mailer:
def __init__(self):
self.smtp_server = "smtp.example.com" # âŒ hardcoded
```

âœ… Good example (externalized to configuration):

```python
class Mailer:
def __init__(self, smtp_server: str):
self.smtp_server = smtp_server
```

---

## ğŸ“Œ 6. Data vs Behavior

âŒ Bad example (mixing DTO and logic):

```python
class User:
def __init__(self, name):
self.name = name

def save_to_db(self): # âŒ
...
```

âœ… Good example (pure DTO):

```python
from dataclasses import dataclass

@dataclass
class User:
name: str
```

---

## ğŸ“Œ 7. SRP in tests

âŒ Bad example:

```python
def test_user_creation_and_login():
user = create_user("test")
assert user.name == "test"
token = login(user)
assert token is not None
```

âœ… Good example (one failure reason = one test):

```python
def test_user_creation():
user = create_user("test")
assert user.name == "test"

def test_user_login():
user = create_user("test")
token = login(user)
assert token is not None
```

---

## ğŸ“Œ 8. SRP in asynchronous tasks

âŒ Bad example:

```python
async def handle_request(data):
# parsing
user_id = data.get("user")
# logic
...
# logging
print("Done")
```

âœ… Good example:

```python
async def parse_request(data): ...
async def business_logic(user_id): ...
async def log(message): ...

async def handle_request(data):
user_id = parse_request(data)
await business_logic(user_id)
await log("Done")
```

---

# âœ… Summary

* **Function = one task**
* **Class = one area of responsibility**
* **Module = one reason to change**
* **Isolation: storage, logic, infrastructure - separate**
