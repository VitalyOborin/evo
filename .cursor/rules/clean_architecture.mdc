---
description: Clean Architecture
globs: 
alwaysApply: true
---

## 0) Базовые принципы

1. Следуй **правилу зависимостей**: исходные зависимости направлены **только внутрь** — от инфраструктуры/фреймворков к приложению и домену. UI, БД, брокеры и т.п. — это детали, замещаемые адаптерами.
2. Строй модуль как **Ports & Adapters (Hexagonal)**: объявляй «порты» (интерфейсы) на границе приложения и реализуй под них адаптеры (SQL, HTTP, брокер, mock/in-mem).
3. Применяй **DDD (тактика)**: сущности, value-objects, **агрегаты как границы консистентности**, доменные сервисы и доменные события. Инварианты обеспечиваются **внутри агрегата** синхронно; **вне агрегата — eventual consistency**.
4. **CQRS — выборочно**: разделяй модель **записи (commands)** и **чтения (queries)** там, где это даёт выигрыш в производительности/простаивает код отчетов. Помни о цене усложнения; не навязывай CQRS «везде». 

## 1) Слои и зависимости (жёсткие запреты/требования)

* **domain/**: чистый Python, **без** FastAPI/SQLAlchemy/HTTP/IO. Только бизнес-модель: Entities, ValueObjects, Aggregates, Domain Events, Domain Services, интерфейсы репозиториев (порты). **Запрет**: импорт из любых внешних библиотек инфраструктуры.
* **application/**: use-cases, **CommandHandlers / QueryHandlers**, **Unit of Work** (порт), **Message/Domain Event bus** (порт), DTO для входа/выхода. Нет ORM и HTTP.
* **infrastructure/**: реализации портов — SQLAlchemy-репозитории, UoW (сессия + транзакция), адаптеры брокера, HTTP-клиенты, outbox. **Инфраструктура знает** об интерфейсах application/domain, но не наоборот.
* **presentation/**: тонкие контроллеры FastAPI, маппинг Pydantic ⇄ Command/Query DTO, валидация и вызов хендлеров. **Запрет**: доступ к ORM/репозиториям из контроллеров. 

## 2) DDD: моделирование домена

* **Агрегат** = минимальная транзакционная граница. Все инварианты — **внутри**. Ссылки на другие агрегаты — по идентификаторам. Между агрегатами/контекстами — события и eventual consistency. 
* **Value Object**: неизменяемый, сравнение по значению, валидирует себя при создании.
* **Доменные события**: поднимаются агрегатами, не делают IO; обработчики событий живут в application и/или публикуются наружу через outbox. 

## 3) Командный путь (write-model)

* Контроллер → Command DTO → **CommandHandler**.
* Хендлер через **UoW** извлекает агрегат из **репозитория (порт)**, выполняет доменную операцию (инварианты внутри агрегата), фиксирует доменные события.
* `UoW.commit()` сохраняет изменения **и** записывает интеграционные события в **Transactional Outbox** в той же транзакции. Паблишер читает outbox и отправляет в брокер (polling или log-tailing/WAL). **Запрет**: прямое паблишинг-IO из домена/хендлера. 

## 4) Запросы (read-model)

* Контроллер → Query DTO → **QueryHandler**.
* Read-модель — отдельные DAO/репозитории на «плоских» SQL/индексах/материализованных представлениях/проекциях; **не** поднимает агрегаты и **не** использует доменную модель. Разрешено иное хранилище/схема для чтения при необходимости.

## 5) Порты и адаптеры

* **Repository (порт)**: интерфейс в домене; **реализация** (SQLAlchemy) в инфраструктуре.
* **Unit of Work (порт)**: абстракция атомарной операции и жизненного цикла транзакции; реализация управляет сессией, трекает новые события агрегатов. 
* **Message/Event Bus (порт)**: внутренний маршрутизатор команд/событий (синхронный) + внешний паблишер через outbox. 
* **Внешние сервисы** (HTTP/SDK): оформить как порты, реализовать адаптеры в инфраструктуре. **Запрет**: прямые вызовы внешних API из домена/хендлеров.

## 6) Транзакции и консистентность

* Одна бизнес-операция write-модели = одна транзакция **внутри агрегата**.
* Межагрегатные/межсервисные эффекты — через события и **eventual consistency**; никаких распределённых 2PC. Выбирай **Transactional Outbox** (+ polling/log-tailing) для надёжной публикации.

## 7) CQRS: когда применять

* Применяй при «тяжёлых» запросах/дашбордах, когда доменная модель мешает производительности, или когда нужны независимые SLA/масштабирование чтения.
* Избегай там, где CRUD прост и отчёты не требуют денормализации — **CQRS добавляет сложность**.

## 8) Контроллеры FastAPI (тонкие края)

* Валидируй вход через Pydantic, **не** вноси бизнес-логики.
* Командам — **идемпотентность** (ключ запроса, повторяемые commit-safe операции), запросам — **кэш/пагинация**.
* Маппинг: Pydantic ⇄ Command/Query DTO; DTO **не** протаскивать внутрь домена.

## 9) Тестирование (пирамида)

* **Юнит-тесты домена**: чистые тесты агрегатов/сервисов без БД/фреймворков.
* **Контрактные тесты портов**: общий suite для репозиториев/шины/внешних клиентов.
* **Интеграционные**: поверх use-cases (UoW + repo + outbox).
* **E2E**: поверх API (write и read пути).

## 10) Стиль и структура проекта (минимум)

```
app/
  domain/ (entities, value_objects, aggregates, events, services, repositories[ports])
  application/ (commands, queries, handlers, uow[port], bus[port], dto)
  presentation/ (api FastAPI: routers/schemas; consumers)
  infrastructure/ (db: models/mappers/repositories/uow; messaging: outbox/publisher; http clients; config)
  readmodel/ (DAO/SQL/проекции)
```

— домен не импортирует ничего "снаружи"; адаптеры зависят от портов.

---

# Definition of Done (автопроверка PR)

1. **Слойность**: файлы домена не импортируют FastAPI/SQLAlchemy/requests. Нарушения — отклонять.
2. **Write-путь**: для каждой команды есть `Command`, `Handler`, использование `UoW`, сохранение доменных событий и запись в **outbox** на commit. Нет прямого паблишинга из хендлера. 
3. **Read-путь**: для каждого запроса — `Query` + `QueryHandler`, работа только с read-DAO/SQL/проекцией; доменные агрегаты **не** поднимаются.
4. **DDD-качество**: инварианты описаны внутри агрегата, кросс-агрегатные правила реализованы событиями/проекциями (eventual consistency). 
5. **Порты**: новые внешние зависимости оформлены как интерфейсы в application/domain; реализации — только в infrastructure. 
6. **Тесты**: есть юнит-тесты агрегатов; контрактные тесты для нового адаптера; интеграционный тест на UoW+repo+outbox; e2e на API. 
