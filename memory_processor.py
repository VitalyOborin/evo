"""
Memory processor module for handling memory operations in a separate process.

This module provides functionality to run the memory agent asynchronously
in a separate process, analyzing user inputs and agent responses to extract
and save relevant facts to memory.
"""

import asyncio
import multiprocessing
import os
from typing import Optional


def run_memory_agent_process(user_input: str, agent_response: str) -> None:
    """
    Entry point for the memory agent process.
    
    This function is called in a separate process to analyze and store
    user interaction data without blocking the main application flow.
    
    Args:
        user_input: The original user query/request
        agent_response: The response generated by the main agent
    """
    # Run the async function in this process
    asyncio.run(_process_memory_async(user_input, agent_response))


async def _process_memory_async(user_input: str, agent_response: str) -> None:
    """
    Asynchronously process and store memory using the memory agent.
    
    Args:
        user_input: The original user query/request
        agent_response: The response generated by the main agent
    """
    try:
        # Import here to avoid circular dependencies and heavy imports in main process
        from agents import Runner
        from ai_agents.memory import create_memory_agent
        
        # Create memory agent
        memory_agent = create_memory_agent()
        
        # Construct the message for memory agent with both input and response
        memory_context = f"""
Analyze the following conversation and extract important facts to save in memory:

USER REQUEST:
{user_input}

AGENT RESPONSE:
{agent_response}

Extract and save all relevant facts, preferences, and important information from this interaction.
"""
        

        result = await Runner.run(memory_agent, memory_context)
        
        # We don't need to do anything with the result - it's just for memory processing
        # The memory agent will use save_memory tool internally to store facts
        
    except Exception as e:
        # Log errors with full traceback for debugging
        import traceback
        print(f"[MEMORY PROCESS] Error in memory processing: {str(e)}")
        print(f"[MEMORY PROCESS] Traceback:\n{traceback.format_exc()}")


def start_memory_processing(user_input: str, agent_response: str) -> Optional[multiprocessing.Process]:
    """
    Start the memory processing in a separate process.
    
    This function creates and starts a new process for memory operations.
    The process runs independently and doesn't block the main application.
    
    Args:
        user_input: The original user query/request
        agent_response: The response generated by the main agent
        
    Returns:
        The started Process instance, or None if process creation failed
        
    Example:
        >>> process = start_memory_processing("What's the weather?", "It's sunny")
        >>> # Main flow continues immediately without waiting
    """
    try:
        # Create a new process for memory operations
        process = multiprocessing.Process(
            target=run_memory_agent_process,
            args=(user_input, agent_response),
            daemon=True  # Daemon process will be terminated when main process exits
        )
        
        # Start the process
        process.start()
        
        return process
        
    except Exception as e:
        print(f"[MEMORY] Warning: Could not start memory processing: {str(e)}")
        return None

